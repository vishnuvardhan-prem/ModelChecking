MODULE sensor(worldval,hwbit,sensorval) --The sensor module can add faults to the readings from the world module as well as pass the hardware flags of the sensor

VAR
    noise:-1..1;

ASSIGN
    next(sensorval):=worldval+noise

MODULE sensorvoter(sv1,hw1,sv2,hw2,sv3,hw3)

VAR
    diff:array 0..2 of 0..4; --Array for the absolute differences between the readings from diffrent pairs of sensors
    pcount: array 0..2 of 0..4; --Persistence counter for pairs that cross the threshold for difference
    hcount: array 0..2 of 0..3; --A count of the number of cyclces for which a sensor is failing
    hwflag: array 0..2 of boolean; --H/W flags for each sensor      
    valid: array 0..2 of boolean; --To keep track of failed sensors 
    numvalid:0..3; --The number of valid sensors available
    set:array 0..2 of boolean; --To allow for count of persisten miscompare when sensors reduce
    outputvalid:boolean;

ASSIGN
    init(diff[0]):=0;
    init(diff[1]):=0;
    init(diff[2]):=0;
    
    init(hwflag[0]):=FALSE;
    init(hwflag[1]):=FALSE;
    init(hwflag[2]):=FALSE;
    
    init(valid[0]):=TRUE;
    init(valid[1]):=TRUE;
    init(valid[2]):=TRUE;

    init(pcount[0]):=0;
    init(pcount[1]):=0;
    init(pcount[2]):=0;
    init(hcount[0]):=0;
    init(hcount[1]):=0;
    init(hcount[2]):=0;

    init(set[0]):=FALSE;    
    init(set[1]):=FALSE;
    init(set[2]):=FALSE;

    next(diff[0]):=abs(b1-b2);
    next(diff[1]):=abs(b2-b3);
    next(diff[2]):=abs(b3-b1);

    next(p[0]):=case
                (diff[0]>2)&(pcount[0]<4)&(numvalid=3):p[0]+1;
                (diff[0]<=2)&(pcount[0]>1)&(numvalid=3):p[0]-1;
                TRUE:p[0];
                esac;

    next(p[1]):=case
                (diff[1]>2)&(pcount[1]<4)&(numvalid=3):p[1]+1;
                (diff[1]<=2)&(pcount[1]>1)&(numvalid=3):p[1]-1;
                TRUE:p[1];
                esac;

    next(p[2]):=case
                (diff[2]>2)&(pcount[2]<4)&(numvalid=3):p[2]+1;
                (diff[2]<=2)&(pcount[2]>1)&(numvalid=3):p[2]-1;
                TRUE:p[2];
                esac;
    
    next(c[0]):=case
                (h1=0)&(hcount[0<3]):hcount[0]+1;
                (h1=1)&(hcount[0]!=0)&(hcount[0]!=3):0;
                TRUE:c[0];
                esac;

    next(c[1]):=case
                (h2=0)&(hcount[1]<3]):hcount[1]+1;
                (h2=1)&(hcount[1]!=0)&(hcount[1]!=3):0;
                TRUE:c[1];
                esac;
    
    next(c[2]):=case
                (h3=0)&(hcount[2]<3]):hcount[2]+1;
                (h3=1)&(hcount[2]!=0)&(hcount[2]!=3):0;
                TRUE:c[2];
                esac;
    
    next(valid[0]):=case 
                (p[0]=4)&(p[2]=4)&(numvalid=3):FALSE;

                TRUE:valid[0];
                esac;
    
    next(valid[1]):=case 
                (p[1]=4)&(p[0]=4)&(numvalid=3):FALSE;
                TRUE:valid[1];
                esac;
    
    next(valid[2]):=case 
                (p[0]=4)&(p[1]=4)&(numvalid=3):FALSE;
                TRUE:valid[2];
                esac;

    numvalid:=case
                    (valid[0]=0)&(valid[1]=1)&(valid[2]=1):2;
                    (valid[0]=1)&(valid[1]=1)&(valid[2]=1):3;
                    (valid[0]=1)&(valid[1]=0)&(valid[2]=1):2;
                    (valid[0]=1)&(valid[1]=1)&(valid[2]=0):2;
                    (valid[0]=1)&(valid[1]=0)&(valid[2]=0):1;
                    (valid[0]=0)&(valid[1]=1)&(valid[2]=0):1;
                    (valid[0]=0)&(valid[1]=0)&(valid[2]=1):1;
                    (valid[0]=0)&(valid[1]=0)&(valid[2]=0):0;
                    TRUE:numvalid;
                   esac
    

MODULE main

VAR
    worldreading: 0..3;
    hwbit:0..1







