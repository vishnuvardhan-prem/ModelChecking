MODULE world(a) --This module is responsible for just passing data values

VAR
    location:{reading};
    worldval:0..5;

ASSIGN
    init(location):=reading;
    init(worldval):=0;

    next(worldval)=a;


MODULE sensor(a,h,b) --The sensor module can add faults to the readings from the world module as well as pass the hardware flags of the sensor

VAR
    k:-1..1;

ASSIGN
    next(b):=a+k

MODULE voter(b1,b2,b3,h1,h2,h3)

VAR
    diff:array 0..2 of 0..4; --This is an array of the absolute differences of the readings of different pairs of the sensors
    pcount:array 0..2 of 0..4;  --A persistence counter for variations in the absolute differences
    hcount:array 0..2 of 0..3;  --A count of the number of cycles for which is a sensor is continously identified with a hardware fault
    error:array 0..2 of boolean; --To keep track of the sensor faults
    numvalid:0..3; --The number of valid sensors available.

ASSIGN
    init(diff[0])=0;
    init(diff[1])=0;
    init(diff[2])=0;
    
    init(error[0]):=FALSE;
    init(error[1]):=FALSE;
    init(error[2]):=FALSE;
    
    init(valid[0]):=TRUE;
    init(valid[1]):=TRUE;
    init(valid[2]):=TRUE;

    init(pcount[0])=0;
    init(pcount[1])=0;
    init(pcount[2])=0;
    init(hcount[0])=0;
    init(hcount[1])=0;
    init(hcount[2])=0;

    next(diff[0])=abs(b1-b2);
    next(diff[1])=abs(b2-b3);
    next(diff[2])=abs(b3-b1);

    next(p[0])=case
                (diff[0]>2)&(pcount[0]<4)&(numvalid=3):p[0]+1;
                (diff[0]<=2)&(pcount[0]>1)&(numvalid=3):p[0]-1;
                TRUE:p[0];
                esac;

    next(p[1])=case
                (diff[1]>2)&(pcount[1]<4)&(numvalid=3):p[1]+1;
                (diff[1]<=2)&(pcount[1]>1)&(numvalid=3):p[1]-1;
                TRUE:p[1];
                esac;

    next(p[2])=case
                (diff[2]>2)&(pcount[2]<4)&(numvalid=3):p[2]+1;
                (diff[2]<=2)&(pcount[2]>1)&(numvalid=3):p[2]-1;
                TRUE:p[2];
                esac;

    next(c[0])=case
                (h1=0)&(hcount[0<3]):hcount[0]+1;
                (h1=1)&(hcount[0]!=0)&(hcount[0]!=3):0;
                TRUE:hcount[0];
                esac;

    next(c[1])=case
                (h2=0)&(hcount[1]<3]):hcount[1]+1;
                (h2=1)&(hcount[1]!=0)&(hcount[1]!=3):0;
                TRUE:hcount[1];
                esac;
    
    next(c[2])=case
                (h3=0)&(hcount[2]<3]):hcount[2]+1;
                (h3=1)&(hcount[2]!=0)&(hcount[2]!=3):0;
                TRUE:hcount[2];
                esac;
                
    next(error[0]):=case
                    (pcount[0]=4)|(hcount[0]=3):TRUE;
                    TRUE:error[0];
                    esac;
    next(error[1]):=case
                    (pcount[1]=4)|(hcount[1]=3):TRUE;
                    TRUE:error[1];
                    esac;
    next(error[2]):=case
                    (pcount[2]=4)|(hcount[2]=3):TRUE;
                    TRUE:error[2];
                    esac;

    next(numvalid):case
                    (error[0]=1)&(error[1]=1)&(error[2]=1):3;
                    (error[0]=0)&(error[1]=1)&(error[2]=1):2;
                    (error[0]=1)&(error[1]=0)&(error[2]=1):2;
                    (error[0]=1)&(error[1]=1)&(error[2]=0):2;
                    (error[0]=1)&(error[1]=0)&(error[2]=0):1;
                    (error[0]=0)&(error[1]=1)&(error[2]=0):1;
                    (error[0]=0)&(error[1]=0)&(error[2]=1):1;
                    (error[0]=0)&(error[1]=0)&(error[2]=0):0;
                    TRUE:numvalid;
                   esac





